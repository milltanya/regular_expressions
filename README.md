# regular_expressions
Formal Languages Practicum #1
Вариант 15

В функции build_automaton по регулярному выражению строится ДКА
следующим образом:
1. Строим НКА:
Будем хранить в стеке промежуточные автоматы.
Если встречена буква, создаём для нее две вершины и ребро по этой букве между
ними и кладём их в стек.
Если встречен +, забираем из стека два последних автомата и проводим
эпсилон-переход из начала первого в начало второго и из конца первого в конец
второго. Кладём в стек автомат, началом и концом которого являются соответственно
начало первого и конец второго.
Если встречена ., забираем из стека два последних автомата, соединяем конец
первого и начало второго эпсилон-переходом, кладём в стек автомат с началом в
начале первого и с концом в конце второго.
Если встречена *, забираем последний автомат и соединяем его конец с его
началом. Кладём в стек автомат с началом и концом в начале этого автомата.
Если в какой-то момент мы не можем взять из стека автоматы, постфиксная запись
некорректна и мы вызываем ошибку.
В конце в стекле должен остаться один автомат, с которым мы и будем дальше
работать.
2. Удаляем эпсилон-переходы:
Перебираем все ребра. Когда встречено ребро по эпсилону, соединяющее u и v,
удаляем это ребро, переписываем все ребра, выходящие из v, в u, удаляем v, во всех
существующих рёбрах в автомате заменяем v на u.
Не забываем, что изначально входной вершиной была нулевая, поэтому тут нужно
будет переписать в входную вершину u, если v была входной и мы ее удалили.
Ребро по 1 из вершины в себя просто удаляем.
3. Строим ДКА:
Начиная с входной вершины рассматриваем переходы по всем возможным буквам
в множества вершин и присваиваем им номера классов. Для входной - 0, далее по
возрастанию. После того, как мы рассмотрели все переходы для классов вершин, мы
можем построить ДКА, в котором вершинами будут классы. В этом автомате из
каждой вершины будет не более одного ребра по каждой букве, то есть это будет ДКА.

В функции find_prefixes_in_automaton ищем максимальный префикс
Идём последовательно по всем символам данной строки, пока можем совершить
переход по символу, начиная с входной вершины (то есть с нулевой). Когда строка
закончится или мы не сможем сделать переход, номер текущего символа и будет
являться длиной максимального префикса, который является префиксом какой-либо
строки в языке.
В этой задаче нам не нужно хранить информацию о терминальных вершинах,
потому что мы рассматриваем все возможные префиксы в языке, то есть нам не нужно
знать, когда заканчивается какое-то слово

В функции find_prefixes строится автомат по регулярному выражению и с
помощью него производится поиск префиксов в данной строке
